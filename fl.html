<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Chat Flow Builder Relacional</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
body { margin:0; font-family:sans-serif; background:#f6f6f6; }
#toolbar { position:fixed; top:10px; left:10px; z-index:30; background:#fff; padding:8px 12px; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); }
button { margin-right:5px; padding:6px 10px; border:1px solid #ccc; border-radius:6px; background:#fafafa; cursor:pointer; }
svg#edges { position:fixed; top:0; left:0; width:100vw; height:100vh; pointer-events:none; z-index:5; }
.node { position:absolute; min-width:180px; background:#fff; border:2px solid #222; border-radius:8px; padding:12px 20px; box-shadow:0 4px 12px rgba(0,0,0,0.1); cursor:grab; z-index:10; user-select:none; }
.node:active { cursor:grabbing; }
.node.editable .title { border-bottom:1px solid #ccc; margin-bottom:8px; padding-bottom:4px; }
.node.editable .title[contenteditable] { outline:none; }
.node input { width:100%; margin:2px 0; padding:4px; border:1px solid #ddd; border-radius:4px; }
.node .remove-btn { float:right; color:red; cursor:pointer; font-size:12px; }
.node .add-step { margin-top:8px; padding:4px 8px; background:#4caf50; color:white; border:none; border-radius:4px; cursor:pointer; }
.node .options-list { margin-top:8px; }
.node .option-item { display:flex; gap:5px; margin:4px 0; }
.ports { position:absolute; top:0; height:100%; display:flex; flex-direction:column; justify-content:center; gap:8px; pointer-events:none; }
.ports.left  { left:0; align-items:flex-start; padding-left:4px; }
.ports.right { right:0; align-items:flex-end;  padding-right:4px; }
.port { width:12px; height:12px; border-radius:50%; background:#444; pointer-events:auto; position:relative; }
.port:hover { background:#0ca5ff; }
#jsonOutput { position:fixed; bottom:10px; left:10px; right:10px; background:#fff; border:1px solid #ccc; border-radius:8px; padding:8px; font-size:12px; max-height:220px; overflow:auto; white-space:pre; }
</style>
</head>
<body>

<div id="toolbar">
  <button id="addTrigger">âž• Trigger (Main)</button>
  <button id="addStep">âž• Step (Pregunta/Decision)</button>
  <button id="addSubflowStep">âž• Subflow Step</button>
  <button id="exportJson">ðŸ“¦ Exportar JSON</button>
  <button id="loadJson">ðŸ“¥ Cargar JSON Ejemplo</button>
</div>

<svg id="edges"></svg>
<pre id="jsonOutput"></pre>

<script>
const svg = document.getElementById("edges");
let connections = [];
let selectedPort = null, tempPath = null;

let flowData = {};
let nodeCounter = 1001;
let subflowIdCounter = 2001;
let stepCounter = { main: 1, subflows: {} };
let mainNode = null;
let nodesById = {};

// ---- Create generic node ----
function createNode(x, y, type, label, key, isEditable = true, flowName = null, stepNum = null, id = null) {
  const node = document.createElement("div");
  node.className = `node ${isEditable ? 'editable' : ''}`;
  node.style.left = x + "px";
  node.style.top = y + "px";
  node.dataset.type = type;
  node.dataset.id = id || nodeCounter++;
  if (flowName) node.dataset.flowName = flowName;
  if (stepNum !== null) node.dataset.stepNum = stepNum;
  if (type === "decision") node.dataset.isDecision = "true";

  const title = document.createElement("div");
  title.className = "title";
  if (isEditable) {
    title.contentEditable = true;
    title.textContent = label;
    title.addEventListener('input', (e) => updateNodeData(node, e.target.textContent));
  } else {
    title.textContent = label;
  }
  node.appendChild(title);

  // Input port (except for main trigger)
  if (type !== "main") {
    const left = document.createElement("div");
    left.className = "ports left";
    const inPort = document.createElement("div");
    inPort.className = "port";
    inPort.dataset.type = "in";
    inPort.dataset.side = "left";
    enablePort(inPort, node);
    left.appendChild(inPort);
    node.appendChild(left);
  }

  // Output port
  const right = document.createElement("div");
  right.className = "ports right";
  const out = document.createElement("div");
  out.className = "port";
  out.dataset.type = "out";
  out.dataset.side = "right";
  enablePort(out, node);
  right.appendChild(out);
  node.appendChild(right);

  // Key input for steps
  if (["step", "subflowStep"].includes(type) && isEditable) {
    const keyInput = document.createElement("input");
    keyInput.placeholder = "Key (e.g., nombre)";
    keyInput.value = key || "";
    keyInput.addEventListener('input', (e) => updateNodeData(node, null, e.target.value));
    node.appendChild(keyInput);
  }

  // For main trigger: triggers input
  if (type === "main" && isEditable) {
    const triggersDiv = document.createElement("div");
    triggersDiv.innerHTML = '<label>Triggers (comma-separated):</label>';
    const triggersInput = document.createElement("input");
    triggersInput.value = flowData["main"]?.triggers?.join(",") || "";
    triggersInput.addEventListener('input', (e) => updateNodeData(node, null, null, e.target.value.split(',').map(t => t.trim())));
    triggersDiv.appendChild(triggersInput);
    node.appendChild(triggersDiv);
  }

  // For decision steps: subflows and options management
  if (type === "decision") {
    const subflowsDiv = document.createElement("div");
    subflowsDiv.className = "options-list";
    subflowsDiv.innerHTML = '<label>Subflows:</label>';
    node.subflowsList = subflowsDiv;
    node.appendChild(subflowsDiv);
  }

  // For steps with options (e.g., tipoCafe, saborHelado)
  if (["step", "subflowStep"].includes(type) && key && isEditable) {
    const optionsDiv = document.createElement("div");
    optionsDiv.className = "options-list";
    optionsDiv.innerHTML = '<label>Opciones (clave:valores):</label>';
    const addOptionBtn = document.createElement("button");
    addOptionBtn.textContent = "+ Add Option";
    addOptionBtn.className = "add-step";
    addOptionBtn.onclick = () => addOptionToStep(node);
    optionsDiv.appendChild(addOptionBtn);
    node.appendChild(optionsDiv);
    node.optionsList = optionsDiv;
  }

  // Add step button for flows
  if (["main", "subflow"].includes(type)) {
    const addStepBtn = document.createElement("button");
    addStepBtn.className = "add-step";
    addStepBtn.textContent = "+ Add Step";
    addStepBtn.onclick = (e) => {
      e.stopPropagation();
      addStepToFlow(node);
    };
    node.appendChild(addStepBtn);
  }

  document.body.appendChild(node);
  nodesById[node.dataset.id] = node;
  enableDrag(node);
  return node;
}

// ---- Add option to step ----
function addOptionToStep(node) {
  const flowName = node.dataset.flowName || "main";
  const stepNum = parseInt(node.dataset.stepNum);
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (!step) return;

  if (!step.options) step.options = {};
  const optionKey = prompt("Clave de la opciÃ³n (e.g., latte):");
  const optionValues = prompt("Valores (comma-separated, e.g., 1,latte):")?.split(',').map(v => v.trim());
  if (optionKey && optionValues) {
    step.options[optionKey] = optionValues;
    updateOptionsList(node);
    updateOutput();
  }
}

// ---- Update options list in step ----
function updateOptionsList(node) {
  const flowName = node.dataset.flowName || "main";
  const stepNum = parseInt(node.dataset.stepNum);
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (step?.options && node.optionsList) {
    const optionsHtml = Object.entries(step.options).map(([key, values]) => `
      <div class="option-item">
        <input value="${key}" placeholder="Clave" onchange="updateOptionKey('${flowName}', ${stepNum}, '${key}', this.value)">
        <input value="${values.join(',')}" placeholder="Valores" onchange="updateOptionValues('${flowName}', ${stepNum}, '${key}', this.value)">
        <span class="remove-btn" onclick="removeOption('${flowName}', ${stepNum}, '${key}')">X</span>
      </div>
    `).join('');
    node.optionsList.innerHTML = '<label>Opciones (clave:valores):</label>' + optionsHtml + '<button class="add-step" onclick="addOptionToStep(this.closest(\'.node\'))">+ Add Option</button>';
  }
}

// ---- Update option key ----
function updateOptionKey(flowName, stepNum, oldKey, newKey) {
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (step?.options && step.options[oldKey]) {
    step.options[newKey] = step.options[oldKey];
    delete step.options[oldKey];
    updateOutput();
    const node = Array.from(document.querySelectorAll('.node')).find(n => n.dataset.flowName === flowName && n.dataset.stepNum == stepNum);
    if (node) updateOptionsList(node);
  }
}

// ---- Update option values ----
function updateOptionValues(flowName, stepNum, key, values) {
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (step?.options && step.options[key]) {
    step.options[key] = values.split(',').map(v => v.trim());
    updateOutput();
    const node = Array.from(document.querySelectorAll('.node')).find(n => n.dataset.flowName === flowName && n.dataset.stepNum == stepNum);
    if (node) updateOptionsList(node);
  }
}

// ---- Remove option ----
function removeOption(flowName, stepNum, key) {
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (step?.options && step.options[key]) {
    delete step.options[key];
    updateOutput();
    const node = Array.from(document.querySelectorAll('.node')).find(n => n.dataset.flowName === flowName && n.dataset.stepNum == stepNum);
    if (node) updateOptionsList(node);
  }
}

// ---- Initialize node data ----
function initNodeData(node, type, question, key, flowName = null, stepNum = null) {
  const id = parseInt(node.dataset.id);
  if (type === "main") {
    flowData["main"] = {
      type: "main",
      id: id,
      triggers: ["hola", "pedido", "quiero"],
      steps: []
    };
    mainNode = node;
  } else if (type === "subflow") {
    if (!flowData[flowName]) {
      flowData[flowName] = {
        type: "subflow",
        id: subflowIdCounter++,
        steps: []
      };
      stepCounter[flowName] = 1;
    }
  }
}

// ---- Update node data ----
function updateNodeData(node, question, key, triggers) {
  const flowName = node.dataset.flowName || "main";
  const stepNum = parseInt(node.dataset.stepNum);
  if (node.dataset.type === "main" && triggers) {
    flowData["main"].triggers = triggers;
  } else if (stepNum) {
    const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
    const step = flow?.steps?.find(s => s.step === stepNum);
    if (step) {
      if (question !== null) step.question = question;
      if (key !== null) step.key = key;
    }
  }
  updateOutput();
}

// ---- Add step to flow ----
function addStepToFlow(flowNode, isDecision = false, question = "New Question", key = null) {
  const type = isDecision ? "decision" : "pregunta";
  const flowName = flowNode.dataset.flowName || "main";
  const stepNum = stepCounter[flowName] || 1;
  const newStepNode = createNode(100 + Math.random() * 200, 100 + Math.random() * 200, "step", question, key || `key${stepNum}`, true, flowName, stepNum);
  newStepNode.dataset.isDecision = isDecision;

  const stepData = {
    step: stepNum,
    question: question,
    key: key || `key${stepNum}`
  };
  if (isDecision) {
    stepData.subflows = {};
  }

  if (flowName === "main") {
    flowData["main"].steps.push(stepData);
    stepCounter.main = stepNum + 1;
  } else {
    flowData[flowName].steps.push(stepData);
    stepCounter[flowName] = stepNum + 1;
  }

  newStepNode.dataset.parentId = flowNode.dataset.id;
  updateOutput();
  return newStepNode;
}

// ---- Create subflow step ----
function createSubflowStep(x, y, subflowName, question, key, stepNum, options = null) {
  if (!flowData[subflowName]) {
    flowData[subflowName] = {
      type: "subflow",
      id: subflowIdCounter++,
      steps: []
    };
    stepCounter[subflowName] = 1;
  }
  const stepNode = createNode(x, y, "subflowStep", question, key, true, subflowName, stepNum);
  const stepData = {
    step: stepNum,
    question: question,
    key: key || null
  };
  if (options) {
    stepData.options = options;
  }
  flowData[subflowName].steps.push(stepData);
  stepCounter[subflowName] = Math.max(stepCounter[subflowName] || 1, stepNum + 1);
  updateOptionsList(stepNode);
  updateOutput();
  return stepNode;
}

// ---- Drag ----
function enableDrag(node) {
  let ox = 0, oy = 0;
  node.addEventListener("mousedown", e => {
    if (e.target.classList.contains("port") || e.target.tagName === "INPUT" || e.target.contentEditable === "true") return;
    ox = e.clientX - node.offsetLeft;
    oy = e.clientY - node.offsetTop;
    node.style.cursor = "grabbing";
    function move(ev) {
      node.style.left = (ev.clientX - ox) + "px";
      node.style.top = (ev.clientY - oy) + "px";
      updateAllPaths();
    }
    function stop() {
      document.removeEventListener("mousemove", move);
      document.removeEventListener("mouseup", stop);
      node.style.cursor = "grab";
    }
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
  });
}

// ---- Ports / Connection ----
function enablePort(port, node) {
  port.addEventListener("click", e => {
    e.stopPropagation();
    if (!selectedPort) {
      if (port.dataset.type !== "out") return;
      selectedPort = { port, node };
      const start = connectionPointFor(port, node);
      tempPath = createPath(start.x, start.y, start.x, start.y);
      function follow(ev) {
        if (tempPath) {
          const s = connectionPointFor(selectedPort.port, selectedPort.node);
          updateCurve(tempPath, s.x, s.y, ev.clientX, ev.clientY);
        }
      }
      function stop() { document.removeEventListener("mousemove", follow); document.removeEventListener("mouseup", stop); }
      document.addEventListener("mousemove", follow);
      document.addEventListener("mouseup", stop);
    } else {
      const from = selectedPort.port, to = port;
      if (from === to) { cleanupTemp(); return; }
      if (from.dataset.type === "out" && to.dataset.type === "in") {
        if (!isDuplicateConnection(from, to)) {
          connections.push([from, to]);
          updateAllPaths();

          const fromNode = selectedPort.node;
          const toNode = to.closest(".node");

          // Main -> Step
          if (fromNode.dataset.type === "main" && toNode.dataset.type === "step") {
            toNode.dataset.flowName = "main";
            const stepNum = parseInt(toNode.dataset.stepNum);
            const step = flowData["main"].steps.find(s => s.step === stepNum);
            if (step) {
              step.question = toNode.querySelector(".title").textContent;
              step.key = toNode.querySelector("input")?.value || step.key;
            }
          }

          // Decision -> Subflow
          if (fromNode.dataset.isDecision === "true" && toNode.dataset.type === "subflowStep") {
            const flowName = toNode.dataset.flowName;
            const stepNum = parseInt(fromNode.dataset.stepNum);
            const parentFlowName = fromNode.dataset.flowName || "main";
            const flow = parentFlowName === "main" ? flowData["main"] : flowData[parentFlowName];
            if (flow && flow.steps) {
              const step = flow.steps.find(s => s.step === stepNum);
              if (step && step.subflows) {
                const subId = flowData[flowName].id;
                const index = Object.keys(step.subflows).length + 1;
                step.subflows[subId] = [String(index), flowName.toLowerCase()];
                updateSubflowsList(fromNode);
              }
            }
          }

          // Subflow step chaining
          if (fromNode.dataset.flowName && toNode.dataset.flowName === fromNode.dataset.flowName && fromNode.dataset.type === "subflowStep" && toNode.dataset.type === "subflowStep") {
            // Chain steps in subflow
            const flowName = fromNode.dataset.flowName;
            const fromStepNum = parseInt(fromNode.dataset.stepNum);
            const toStepNum = parseInt(toNode.dataset.stepNum);
            const flow = flowData[flowName];
            if (flow?.steps) {
              // Ensure steps are ordered
              flow.steps.sort((a, b) => a.step - b.step);
            }
          }
        }
      }
      cleanupTemp();
      updateOutput();
    }
  });
}

// ---- Update subflows list in decision node ----
function updateSubflowsList(decisionNode) {
  const flowName = decisionNode.dataset.flowName || "main";
  const stepNum = parseInt(decisionNode.dataset.stepNum);
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  if (flow && flow.steps) {
    const step = flow.steps.find(s => s.step === stepNum);
    if (step?.subflows && decisionNode.subflowsList) {
      const subflowsHtml = Object.entries(step.subflows).map(([id, [num, name]]) => `
        <li>${num}: ${name} (ID: ${id})
          <span class="remove-btn" onclick="removeSubflow('${flowName}', ${stepNum}, '${id}')">X</span>
        </li>
      `).join('');
      decisionNode.subflowsList.innerHTML = '<label>Subflows:</label><ul>' + subflowsHtml + '</ul>';
    }
  }
}

// ---- Remove subflow connection ----
function removeSubflow(flowName, stepNum, subflowId) {
  const flow = flowName === "main" ? flowData["main"] : flowData[flowName];
  const step = flow?.steps?.find(s => s.step === stepNum);
  if (step?.subflows && step.subflows[subflowId]) {
    delete step.subflows[subflowId];
    updateOutput();
    const decisionNode = Array.from(document.querySelectorAll('.node')).find(n => n.dataset.flowName === flowName && n.dataset.stepNum == stepNum);
    if (decisionNode) updateSubflowsList(decisionNode);
    // Remove connection visually
    connections = connections.filter(([_, to]) => to.closest('.node').dataset.id != subflowId);
    updateAllPaths();
  }
}

// ---- Helpers ----
function isDuplicateConnection(a, b) { return connections.some(([x, y]) => x === a && y === b); }
function connectionPointFor(port, node) {
  const rect = port.getBoundingClientRect();
  const nrect = node.getBoundingClientRect();
  const y = rect.top + rect.height / 2;
  return (port.dataset.side === "right") ? { x: nrect.left + nrect.width, y } : { x: nrect.left, y };
}
function createPath(x1, y1, x2, y2) {
  const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
  p.setAttribute("stroke", "#666");
  p.setAttribute("stroke-width", "2.5");
  p.setAttribute("fill", "none");
  updateCurve(p, x1, y1, x2, y2);
  svg.appendChild(p);
  return p;
}
function updateCurve(path, x1, y1, x2, y2) {
  const dx = Math.max(40, Math.abs(x2 - x1) * 0.45);
  path.setAttribute("d", `M ${x1},${y1} C ${x1 + dx},${y1} ${x2 - dx},${y2} ${x2},${y2}`);
}
function cleanupTemp() { if (tempPath && tempPath.parentNode) tempPath.parentNode.removeChild(tempPath); tempPath = null; selectedPort = null; }
function updateAllPaths() {
  svg.innerHTML = "";
  connections.forEach(([out, inP]) => {
    const oNode = out.closest(".node"), iNode = inP.closest(".node");
    const p1 = connectionPointFor(out, oNode), p2 = connectionPointFor(inP, iNode);
    createPath(p1.x, p1.y, p2.x, p2.y);
  });
}

// ---- Load JSON Example ----
function loadJsonExample() {
  const jsonExample = {
    "main": {
      "type": "main",
      "id": 1001,
      "triggers": ["hola", "pedido", "quiero"],
      "steps": [
        {
          "step": 1,
          "question": "ðŸ‘‹ Hola, Â¿cuÃ¡l es tu nombre?",
          "key": "nombre"
        },
        {
          "step": 2,
          "question": "Â¡QuÃ© bien {{nombre}}! Â¿QuÃ© deseas pedir hoy?\n1. CafÃ©\n2. Helado\n3. Pizza",
          "key": "opcion",
          "subflows": {
            "2001": ["1", "cafe"],
            "2002": ["2", "helado"],
            "2003": ["3", "pizza"]
          }
        }
      ]
    },
    "cafe": {
      "type": "subflow",
      "id": 2001,
      "steps": [
        {
          "step": 1,
          "question": "Â¿QuÃ© tipo de cafÃ© deseas?\n1. Latte\n2. Americano\n3. Cappuccino",
          "key": "tipoCafe",
          "options": {
            "latte": ["1", "latte"],
            "americano": ["2", "americano"],
            "cappuccino": ["3", "cappuccino"]
          }
        },
        {
          "step": 2,
          "question": "Â¿Con azÃºcar o sin azÃºcar?\n1. Con azÃºcar\n2. Sin azÃºcar",
          "key": "azucar",
          "options": {
            "con azucar": ["1", "con", "con azucar"],
            "sin azucar": ["2", "sin", "sin azucar"]
          }
        },
        {
          "step": 3,
          "question": "Gracias, tu cafÃ© serÃ¡ preparado â˜•ï¸ {{tipoCafe}} {{azucar}}",
          "key": null
        }
      ]
    },
    "helado": {
      "type": "subflow",
      "id": 2002,
      "steps": [
        {
          "step": 1,
          "question": "Â¿QuÃ© sabor de helado deseas?\n1. Chocolate\n2. Vainilla\n3. Fresa",
          "key": "saborHelado",
          "options": {
            "chocolate": ["1", "chocolate"],
            "vainilla": ["2", "vainilla"],
            "fresa": ["3", "fresa"]
          }
        },
        {
          "step": 2,
          "question": "Â¿En quÃ© lo quieres?\n1. Cono\n2. Vaso",
          "key": "presentacion",
          "options": {
            "cono": ["1", "cono"],
            "vaso": ["2", "vaso"]
          }
        },
        {
          "step": 3,
          "question": "Genial, tu helado estÃ¡ en camino ðŸ¦ {{saborHelado}} en {{presentacion}}",
          "key": null
        }
      ]
    },
    "pizza": {
      "type": "subflow",
      "id": 2003,
      "steps": [
        {
          "step": 1,
          "question": "Â¿De quÃ© sabor quieres la pizza?\n1. Pepperoni\n2. Hawaiana\n3. Margarita",
          "key": "saborPizza",
          "options": {
            "pepperoni": ["1", "pepperoni"],
            "hawaiana": ["2", "hawaiana"],
            "margarita": ["3", "margarita"]
          }
        },
        {
          "step": 2,
          "question": "Â¿QuÃ© tamaÃ±o deseas?\n1. PequeÃ±a\n2. Mediana\n3. Grande",
          "key": "tamanoPizza",
          "options": {
            "pequeÃ±a": ["1", "pequeÃ±a", "chica"],
            "mediana": ["2", "mediana"],
            "grande": ["3", "grande"]
          }
        },
        {
          "step": 3,
          "question": "Perfecto {{nombre}} ðŸ•, tu pizza {{saborPizza}} tamaÃ±o {{tamanoPizza}} estÃ¡ en camino.",
          "key": null
        }
      ]
    }
  };

  // Reset existing data
  flowData = {};
  connections = [];
  nodesById = {};
  document.querySelectorAll('.node').forEach(n => n.remove());
  svg.innerHTML = "";
  mainNode = null;
  nodeCounter = 1001;
  subflowIdCounter = 2001;
  stepCounter = { main: 1, subflows: {} };

  // Create main trigger
  const main = jsonExample.main;
  const mainNode = createNode(80, 120, "main", "ðŸ‘‹ Main Trigger", null, true, "main", null, main.id);
  flowData["main"] = main;
  stepCounter.main = main.steps.length + 1;
  let posX = 300;

  // Create main flow steps
  main.steps.forEach(step => {
    const isDecision = !!step.subflows;
    const stepNode = createNode(posX, 120, "step", step.question, step.key, true, "main", step.step);
    stepNode.dataset.isDecision = isDecision;
    if (isDecision) {
      stepNode.subflowsList.innerHTML = '<label>Subflows:</label><ul>' + Object.entries(step.subflows).map(([id, [num, name]]) => `
        <li>${num}: ${name} (ID: ${id})
          <span class="remove-btn" onclick="removeSubflow('main', ${step.step}, '${id}')">X</span>
        </li>
      `).join('') + '</ul>';
    }
    if (step.options) updateOptionsList(stepNode);
    // Connect main to first step, or previous step to this
    const prevNode = nodesById[main.id] || nodesById[`main-step-${step.step - 1}`];
    if (prevNode) {
      const outPort = prevNode.querySelector('.port[data-type="out"]');
      const inPort = stepNode.querySelector('.port[data-type="in"]');
      connections.push([outPort, inPort]);
    }
    nodesById[`main-step-${step.step}`] = stepNode;
    posX += 220;
  });

  // Create subflows and their steps
  ['cafe', 'helado', 'pizza'].forEach(subflowName => {
    const subflow = jsonExample[subflowName];
    flowData[subflowName] = subflow;
    stepCounter[subflowName] = subflow.steps.length + 1;
    let subPosY = 300 + ['cafe', 'helado', 'pizza'].indexOf(subflowName) * 300;
    let subPosX = 80;

    // Create a subflow node for visualization
    const subflowNode = createNode(subPosX, subPosY, "subflow", subflowName.charAt(0).toUpperCase() + subflowName.slice(1), null, false, subflowName, null, subflow.id);
    subPosX += 220;

    // Create subflow steps
    subflow.steps.forEach(step => {
      const stepNode = createSubflowStep(subPosX, subPosY, subflowName, step.question, step.key, step.step, step.options);
      if (step.options) updateOptionsList(stepNode);
      // Connect steps within subflow
      const prevNode = nodesById[`${subflowName}-step-${step.step - 1}`] || subflowNode;
      if (prevNode) {
        const outPort = prevNode.querySelector('.port[data-type="out"]');
        const inPort = stepNode.querySelector('.port[data-type="in"]');
        connections.push([outPort, inPort]);
      }
      nodesById[`${subflowName}-step-${step.step}`] = stepNode;
      subPosX += 220;
    });

    // Connect decision to subflow
    const decisionStep = main.steps.find(s => s.subflows && s.subflows[subflow.id]);
    if (decisionStep) {
      const decisionNode = nodesById[`main-step-${decisionStep.step}`];
      const subflowFirstStep = nodesById[`${subflowName}-step-1`];
      if (decisionNode && subflowFirstStep) {
        const outPort = decisionNode.querySelector('.port[data-type="out"]');
        const inPort = subflowFirstStep.querySelector('.port[data-type="in"]');
        connections.push([outPort, inPort]);
      }
    }
  });

  updateAllPaths();
  updateOutput();
}

// ---- Toolbar ----
document.getElementById("addTrigger").onclick = () => {
  if (mainNode) {
    alert("Solo un trigger (main) permitido.");
    return;
  }
  let posX = 80;
  mainNode = createNode(posX, 120, "main", "ðŸ‘‹ Main Trigger", null, true);
  mainNode.dataset.flowName = "main";
  posX += 220;
  stepCounter.main = 1;
};
document.getElementById("addStep").onclick = () => {
  if (!mainNode) {
    alert("Crea el Main Trigger primero.");
    return;
  }
  const isDecision = confirm("Â¿Es una decisiÃ³n (con subflows)?");
  const posX = 80 + (stepCounter.main - 1) * 220;
  addStepToFlow(mainNode, isDecision);
};
document.getElementById("addSubflowStep").onclick = () => {
  const subflowName = prompt("Nombre del subflow (e.g., cafe):") || "newSubflow";
  const question = prompt("Pregunta del step:") || "New subflow step";
  const key = prompt("Key (optional):") || null;
  createSubflowStep(80 + Math.random() * 200, 300 + Math.random() * 200, subflowName, question, key, stepCounter[subflowName] || 1);
};
document.getElementById("exportJson").onclick = () => {
  const jsonStr = JSON.stringify(flowData, null, 2);
  const blob = new Blob([jsonStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'flow.json';
  a.click();
  URL.revokeObjectURL(url);
};
document.getElementById("loadJson").onclick = loadJsonExample;

function updateOutput() {
  document.getElementById("jsonOutput").textContent = JSON.stringify(flowData, null, 2);
}

updateAllPaths();
document.addEventListener("click", e => { if (!e.target.classList.contains("port")) cleanupTemp(); });

// Load the JSON example on page load
window.onload = loadJsonExample;
</script>
</body>
</html>