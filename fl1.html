<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Editor (JSON service format) â€” Main + Subflows</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#0d1720;--panel:#0b1220;--muted:#9aa4b2;--accent:#2563eb}
  body{margin:0;display:flex;height:100vh;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#e6eef6}
  #left{flex:1;display:flex;flex-direction:column;border-right:1px solid #0f2536;min-width:480px}
  #toolbar{padding:10px;background:#081026;display:flex;gap:8px;align-items:center}
  button{background:#112a44;color:#fff;border:1px solid #163b63;padding:8px 10px;border-radius:6px;cursor:pointer}
  button.secondary{background:#071425;border:1px solid #21364a}
  #canvasWrap{flex:1;position:relative;overflow:auto;background:linear-gradient(180deg,#07101a 0%,#06121b 100%);padding:12px}
  .flow-area{position:relative;min-height:600px}
  .node{
    position:absolute;min-width:220px;padding:10px;border-radius:8px;background:#08232e;border:1px solid #153d4f;box-shadow:0 6px 18px rgba(2,6,23,0.6);cursor:grab;
  }
  .node h4{margin:0 0 6px 0;font-size:13px}
  .node p{margin:0;font-size:13px;white-space:pre-wrap}
  .node small{display:block;color:#9aa4b2;margin-top:6px}
  #right{width:480px;padding:12px;display:flex;flex-direction:column;gap:8px;background:#071127}
  #editorPanel{background:var(--panel);padding:10px;border-radius:8px;border:1px solid #0f2436;min-height:140px;overflow:auto}
  label{font-size:13px;color:var(--muted);display:block;margin-top:8px}
  input[type=text], textarea, select{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;background:#061222;color:#e6eef6;border:1px solid #163245}
  textarea{min-height:60px;resize:vertical}
  pre#jsonOut{background:#051019;padding:8px;border-radius:6px;border:1px solid #163245;color:#cfe6ff;max-height:220px;overflow:auto;font-family:monospace;font-size:12px}
  #chat{background:#061018;border:1px solid #123;padding:8px;border-radius:8px;display:flex;flex-direction:column;gap:8px}
  #chatBox{height:220px;overflow:auto;padding:8px;border-radius:6px;background:#041018;border:1px solid #072}
  .msg{padding:6px 8px;border-radius:8px;max-width:85%;font-size:14px;word-wrap:break-word;}
  .msg.bot{background:#0b2a3a;color:#dff7ff;align-self:flex-start}
  .msg.user{background:#0b2a0b;color:#e9ffdf;align-self:flex-end}
  .row{display:flex;gap:8px;align-items:center}
  .muted{font-size:12px;color:var(--muted)}
  .small{font-size:12px;color:var(--muted);margin-top:4px}
</style>
</head>
<body>

  <div id="left">
    <div id="toolbar">
      <button id="btnAddMainStep">+ Paso (main)</button>
      <button id="btnAddSubflow">+ Crear subflow (ej: cafe)</button>
      <input id="newSubflowName" placeholder="nombre subflow (ej: cafe)" style="padding:8px;border-radius:6px;background:#061222;color:#cfe6ff;border:1px solid #163245"/>
      <div style="flex:1"></div>
      <button id="btnCenter" class="secondary">Recentrar</button>
      <button id="btnImport">Importar JSON</button>
      <button id="btnExport">Copiar JSON</button>
    </div>

    <div id="canvasWrap">
      <div class="flow-area" id="flowArea"></div>
    </div>
  </div>

  <div id="right">
    <div id="editorPanel">
      <h3 style="margin:0">Editor (JSON service format)</h3>
      <div class="small">Edita pasos/subflows en el canvas, o usa la secciÃ³n para editar el nodo seleccionado.</div>

      <label>Seleccionado:</label>
      <div id="selInfo" class="muted">Ninguno</div>

      <div id="selForm" style="display:none">
        <label>Texto / Pregunta</label>
        <textarea id="selQuestion"></textarea>

        <label>Key (variable) â€” usar {{key}} en preguntas finales</label>
        <input id="selKey" type="text"/>

        <label>Options (JSON) â€” para respuestas tipo opciÃ³n dentro del mismo flow (ej: {"chocolate":["1","chocolate"],...})</label>
        <textarea id="selOptions" placeholder='Dejar vacÃ­o si no aplica'></textarea>

        <label>Subflows mapping (JSON) â€” sÃ³lo para step que debe ramificar a subflows (ej: {"2001":["1","cafe"],...})</label>
        <textarea id="selSubflows" placeholder='Dejar vacÃ­o si no aplica'></textarea>

        <div class="row">
          <button id="btnSaveNode">Guardar</button>
          <button id="btnDeleteNode" style="background:#3b1111">Eliminar</button>
        </div>
      </div>

      <label class="muted">JSON en vivo</label>
      <pre id="jsonOut"></pre>
    </div>

    <div id="chat">
      <h4 style="margin:0">Chat simulador</h4>
      <div id="chatBox"></div>
      <div class="row">
        <input id="userInput" placeholder="Escribe aquÃ­..." style="flex:1"/>
        <button id="btnSend">Enviar</button>
        <button id="btnReset" class="secondary">Reset</button>
      </div>
      <div class="small">El chat usa el JSON actual (triggers en main) para iniciar y navegar opciones/subflows.</div>
    </div>
  </div>

<script>
/* ------------------ JSON (la Ãºnica fuente de verdad) ------------------ */
/* Pre-cargamos exactamente el JSON que pediste, con coordenadas x,y (editable) */
let flowJSON = {
  "main": {
    "type": "main",
    "id": 1001,
    "triggers": ["hola", "pedido", "quiero"],
    "steps": [
      {
        "step": 1,
        "question": "ðŸ‘‹ Hola, Â¿cuÃ¡l es tu nombre?",
        "key": "nombre",
        "x": 80,
        "y": 80
      },
      {
        "step": 2,
        "question": "Â¡QuÃ© bien {{nombre}}! Â¿QuÃ© deseas pedir hoy?\n1. CafÃ©\n2. Helado\n3. Pizza",
        "key": "opcion",
        "subflows": {
          "2001": ["1", "cafe"],
          "2002": ["2", "helado"],
          "2003": ["3", "pizza"]
        },
        "x": 340,
        "y": 80
      }
    ]
  },
  "cafe": {
    "type": "subflow",
    "id": 2001,
    "steps": [
      {
        "step": 1,
        "question": "Â¿QuÃ© tipo de cafÃ© deseas?\n1. Latte\n2. Americano\n3. Cappuccino",
        "key": "tipoCafe",
        "options": {
          "latte": ["1", "latte"],
          "americano": ["2", "americano"],
          "cappuccino": ["3", "cappuccino"]
        },
        "x": 80,
        "y": 280
      },
      {
        "step": 2,
        "question": "Â¿Con azÃºcar o sin azÃºcar?\n1. Con azÃºcar\n2. Sin azÃºcar",
        "key": "azucar",
        "options": {
          "con azucar": ["1", "con", "con azucar"],
          "sin azucar": ["2", "sin", "sin azucar"]
        },
        "x": 360,
        "y": 280
      },
      {
        "step": 3,
        "question": "Gracias, tu cafÃ© serÃ¡ preparado â˜•ï¸ {{tipoCafe}} {{azucar}}",
        "key": null,
        "x": 640,
        "y": 280
      }
    ]
  },
  "helado": {
    "type": "subflow",
    "id": 2002,
    "steps": [
      {
        "step": 1,
        "question": "Â¿QuÃ© sabor de helado deseas?\n1. Chocolate\n2. Vainilla\n3. Fresa",
        "key": "saborHelado",
        "options": {
          "chocolate": ["1", "chocolate"],
          "vainilla": ["2", "vainilla"],
          "fresa": ["3", "fresa"]
        },
        "x": 80,
        "y": 480
      },
      {
        "step": 2,
        "question": "Â¿En quÃ© lo quieres?\n1. Cono\n2. Vaso",
        "key": "presentacion",
        "options": {
          "cono": ["1", "cono"],
          "vaso": ["2", "vaso"]
        },
        "x": 360,
        "y": 480
      },
      {
        "step": 3,
        "question": "Genial, tu helado estÃ¡ en camino ðŸ¦ {{saborHelado}} en {{presentacion}}",
        "key": null,
        "x": 640,
        "y": 480
      }
    ]
  },
  "pizza": {
    "type": "subflow",
    "id": 2003,
    "steps": [
      {
        "step": 1,
        "question": "Â¿De quÃ© sabor quieres la pizza?\n1. Pepperoni\n2. Hawaiana\n3. Margarita",
        "key": "saborPizza",
        "options": {
          "pepperoni": ["1", "pepperoni"],
          "hawaiana": ["2", "hawaiana"],
          "margarita": ["3", "margarita"]
        },
        "x": 80,
        "y": 680
      },
      {
        "step": 2,
        "question": "Â¿QuÃ© tamaÃ±o deseas?\n1. PequeÃ±a\n2. Mediana\n3. Grande",
        "key": "tamanoPizza",
        "options": {
          "pequeÃ±a": ["1", "pequeÃ±a", "chica"],
          "mediana": ["2", "mediana"],
          "grande": ["3", "grande"]
        },
        "x": 360,
        "y": 680
      },
      {
        "step": 3,
        "question": "Perfecto {{nombre}} ðŸ•, tu pizza {{saborPizza}} tamaÃ±o {{tamanoPizza}} estÃ¡ en camino.",
        "key": null,
        "x": 640,
        "y": 680
      }
    ]
  }
};

/* ------------------ UI references ------------------ */
const flowArea = document.getElementById('flowArea');
const jsonOut = document.getElementById('jsonOut');
const selInfo = document.getElementById('selInfo');
const selForm = document.getElementById('selForm');
const selQuestion = document.getElementById('selQuestion');
const selKey = document.getElementById('selKey');
const selOptions = document.getElementById('selOptions');
const selSubflows = document.getElementById('selSubflows');
let selected = null; // {flowName, stepIndex}

/* ------------------ Helpers ------------------ */
function refreshJSONView(){ jsonOut.textContent = JSON.stringify(flowJSON, null, 2); }
function flowNames(){ return Object.keys(flowJSON); }
function getSteps(flowName){ return (flowJSON[flowName] && flowJSON[flowName].steps) || []; }
function ensureSubflow(name){
  if(!flowJSON[name]){
    // create with new id (2000 + next)
    const nextId = 2000 + Object.keys(flowJSON).length;
    flowJSON[name] = { type:'subflow', id: nextId, steps: [] };
  }
}

/* ------------------ Render canvas (nodes) ------------------ */
function renderCanvas(){
  flowArea.innerHTML = '';
  // iterate flows in order: main first, then others
  const order = Object.keys(flowJSON);
  order.forEach(flowName=>{
    const flow = flowJSON[flowName];
    // a small header block for each flow area
    const header = document.createElement('div');
    header.style.position='absolute';
    header.style.left = (flow.steps && flow.steps.length>0 ? Math.min(...flow.steps.map(s=>s.x||0))-20 : 20) + 'px';
    header.style.top = ((flow.steps && flow.steps.length>0 ? Math.min(...flow.steps.map(s=>s.y||0)) : 20) - 32) + 'px';
    header.style.color='#9aa4b2';
    header.style.fontSize='13px';
    header.textContent = `${flowName} (${flow.type})`;
    flowArea.appendChild(header);

    (flow.steps||[]).forEach((step, idx)=>{
      const node = document.createElement('div');
      node.className = 'node';
      node.style.left = (step.x || 120) + 'px';
      node.style.top = (step.y || 120 + idx*80) + 'px';
      node.dataset.flow = flowName;
      node.dataset.index = idx;
      node.innerHTML = `<h4>(${flowName}) Step ${step.step}</h4>
                        <p>${escapeHtml(step.question||'')}</p>
                        <small>key: ${step.key||'â€”'}</small>`;
      // drag
      node.addEventListener('mousedown', nodeMouseDown);
      node.addEventListener('dblclick', ()=> selectNode(flowName, idx));
      flowArea.appendChild(node);
    });
  });
  refreshJSONView();
}

/* Dragging implementation (simple) */
let dragNode = null;
let offsetX=0, offsetY=0;
function nodeMouseDown(e){
  dragNode = e.currentTarget;
  offsetX = e.offsetX; offsetY = e.offsetY;
  document.addEventListener('mousemove', nodeMouseMove);
  document.addEventListener('mouseup', nodeMouseUp);
  dragNode.style.cursor='grabbing';
}
function nodeMouseMove(e){
  if(!dragNode) return;
  const rect = flowArea.getBoundingClientRect();
  let nx = e.pageX - rect.left - offsetX;
  let ny = e.pageY - rect.top - offsetY;
  if(nx<0) nx=0; if(ny<0) ny=0;
  dragNode.style.left = nx + 'px';
  dragNode.style.top = ny + 'px';
}
function nodeMouseUp(e){
  if(!dragNode) return;
  const flowName = dragNode.dataset.flow;
  const idx = parseInt(dragNode.dataset.index,10);
  const rect = flowArea.getBoundingClientRect();
  const x = parseInt(dragNode.style.left,10);
  const y = parseInt(dragNode.style.top,10);
  // update JSON
  const steps = getSteps(flowName);
  if(steps[idx]){
    steps[idx].x = x;
    steps[idx].y = y;
  }
  dragNode.style.cursor='grab';
  dragNode = null;
  document.removeEventListener('mousemove', nodeMouseMove);
  document.removeEventListener('mouseup', nodeMouseUp);
  renderCanvas();
}

/* ------------------ Select & Edit node ------------------ */
function selectNode(flowName, idx){
  selected = {flowName, idx};
  const step = getSteps(flowName)[idx];
  selInfo.textContent = `${flowName} â€” step ${step.step}`;
  selForm.style.display = 'block';
  selQuestion.value = step.question || '';
  selKey.value = step.key || '';
  selOptions.value = step.options ? JSON.stringify(step.options, null, 2) : '';
  selSubflows.value = step.subflows ? JSON.stringify(step.subflows, null, 2) : '';
  // scroll editor panel into view
  document.getElementById('selQuestion').scrollIntoView({behavior:'smooth',block:'center'});
}

/* Save selected */
document.getElementById('btnSaveNode').addEventListener('click', ()=>{
  if(!selected) return;
  const {flowName, idx} = selected;
  const step = getSteps(flowName)[idx];
  step.question = selQuestion.value;
  const k = selKey.value.trim();
  step.key = k === '' ? null : k;
  // parse options
  const optText = selOptions.value.trim();
  if(optText==='') delete step.options;
  else {
    try{ step.options = JSON.parse(optText); } catch(e){ alert('Options JSON invÃ¡lido'); return; }
  }
  const sfText = selSubflows.value.trim();
  if(sfText==='') delete step.subflows;
  else {
    try{ step.subflows = JSON.parse(sfText); } catch(e){ alert('Subflows JSON invÃ¡lido'); return; }
  }
  renderCanvas();
});

/* Delete selected */
document.getElementById('btnDeleteNode').addEventListener('click', ()=>{
  if(!selected) return;
  if(!confirm('Eliminar este step?')) return;
  const {flowName, idx} = selected;
  const steps = getSteps(flowName);
  steps.splice(idx,1);
  // reindex steps.step
  steps.forEach((s,i)=> s.step = i+1);
  selected = null;
  selForm.style.display='none';
  renderCanvas();
});

/* ------------------ Add step in main ------------------ */
document.getElementById('btnAddMainStep').addEventListener('click', ()=>{
  const steps = flowJSON.main.steps;
  const newStep = {
    step: steps.length + 1,
    question: 'Nueva pregunta en main',
    key: null,
    x: 120 + (steps.length*40)%500,
    y: 60 + (steps.length*60)%500
  };
  steps.push(newStep);
  renderCanvas();
});

/* Create subflow */
document.getElementById('btnAddSubflow').addEventListener('click', ()=>{
  const name = (document.getElementById('newSubflowName').value || '').trim();
  if(!name){ alert('Escribe nombre de subflow (ej: cafe)'); return; }
  if(flowJSON[name]) { alert('Ya existe subflow con ese nombre'); return; }
  // create id = 2000 + next available
  const usedIds = Object.values(flowJSON).map(f=>f.id).filter(Boolean);
  let nextId = 2001;
  while(usedIds.includes(nextId)) nextId++;
  flowJSON[name] = { type:'subflow', id: nextId, steps: [] };
  // add a sample step
  flowJSON[name].steps.push({
    step:1,
    question: 'Nueva pregunta en '+name,
    key: null,
    options: {},
    x: 100,
    y: 200 + Object.keys(flowJSON).length*40
  });
  document.getElementById('newSubflowName').value='';
  renderCanvas();
});

/* Import JSON (replace) */
document.getElementById('btnImport').addEventListener('click', ()=>{
  const txt = prompt('Pega aquÃ­ el JSON completo para cargar (reemplazarÃ¡ el actual)');
  if(!txt) return;
  try{
    const obj = JSON.parse(txt);
    flowJSON = obj;
    renderCanvas();
  }catch(e){ alert('JSON invÃ¡lido'); }
});

/* Export / copy JSON */
document.getElementById('btnExport').addEventListener('click', ()=>{
  const txt = JSON.stringify(flowJSON, null, 2);
  navigator.clipboard.writeText(txt).then(()=> alert('JSON copiado al portapapeles'));
});

/* Center view */
document.getElementById('btnCenter').addEventListener('click', ()=> { document.getElementById('canvasWrap').scrollTo({top:0,left:0,behavior:'smooth'}) });

/* ------------------ Chat simulator ------------------ */
const chatBox = document.getElementById('chatBox');
const userInput = document.getElementById('userInput');
let chatState = { flow:'main', stepIndex:0, subflowStack:[], vars:{} };

function chatReset(){
  chatBox.innerHTML='';
  chatState = { flow:'main', stepIndex:0, subflowStack:[], vars:{} };
  addBot("ðŸ‘‹ Escribe un trigger (ej: hola) para iniciar.");
}
document.getElementById('btnReset').addEventListener('click', chatReset);
document.getElementById('btnSend').addEventListener('click', ()=> {
  const v = userInput.value.trim();
  if(!v) return;
  addUser(v);
  userInput.value='';
  chatReceive(v.trim());
});

function addBot(txt){ const d=document.createElement('div'); d.className='msg bot'; d.innerText=txt; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight; }
function addUser(txt){ const d=document.createElement('div'); d.className='msg user'; d.innerText=txt; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight; }

function chatReceive(inputRaw){
  const input = inputRaw.toLowerCase();

  // Step 0 = waiting triggers
  if(chatState.stepIndex===0 && chatState.subflowStack.length===0){
    const triggers = (flowJSON.main.triggers||[]).map(t=>t.toLowerCase());
    if(triggers.some(t=> input.includes(t) )){
      // start main step 0 -> show first main step (stepIndex 0 maps to steps[0])
      chatState.stepIndex = 0;
      chatAskCurrent();
    } else {
      addBot("No reconozco ese trigger. Usa: " + (flowJSON.main.triggers||[]).join(', '));
    }
    return;
  }

  // We're inside a flow (main or subflow)
  chatHandleAnswer(input);
}

function getCurrentFlowObj(){
  const name = chatState.subflowStack.length>0 ? chatState.subflowStack[chatState.subflowStack.length-1].name : 'main';
  return flowJSON[name];
}
function chatAskCurrent(){
  const name = chatState.subflowStack.length>0 ? chatState.subflowStack[chatState.subflowStack.length-1].name : 'main';
  const steps = getSteps(name);
  if(!steps || steps.length===0){ addBot('Flujo vacÃ­o'); return; }
  if(chatState.stepIndex >= steps.length){
    // end of this flow
    if(chatState.subflowStack.length>0){
      // pop subflow and continue parent (we assume parent already advanced)
      chatState.subflowStack.pop();
      chatState.stepIndex = chatState.subflowStack.length>0 ? chatState.subflowStack[chatState.subflowStack.length-1].indexAfter : 0;
      chatAskCurrent();
      return;
    } else {
      addBot('âœ… Fin del flujo principal.');
      chatState.stepIndex = 0; chatState.subflowStack = []; chatState.vars={};
      return;
    }
  }
  const step = steps[chatState.stepIndex];
  addBot(step.question || '(sin texto)');
}

function chatHandleAnswer(input){
  const name = chatState.subflowStack.length>0 ? chatState.subflowStack[chatState.subflowStack.length-1].name : 'main';
  const steps = getSteps(name);
  if(!steps) return;
  const step = steps[chatState.stepIndex];
  if(!step) return;

  // Save into variable if key defined
  if(step.key){
    chatState.vars[step.key] = input;
  }

  // If this step has subflows (mapping), check whether input matches any mapping -> push subflow
  if(step.subflows){
    const map = step.subflows;
    // map: { "2001": ["1", "cafe"], ... } we check values arrays for input (numbers or keywords)
    let matched = null;
    for(const k in map){
      const arr = map[k].map(v=> (''+v).toLowerCase());
      if(arr.some(a=> input.includes(a) )){ matched = {subflowId:k, val:arr}; break; }
    }
    if(matched){
      // push subflow details: need to find subflow name from mapping value (e.g. "cafe")
      const subflowName = matched.val[1] || null;
      if(subflowName && flowJSON[subflowName]){
        // save parent index to return to (we'll assume after selecting, main stops and we return when subflow ends)
        chatState.subflowStack.push({name: subflowName, indexAfter: chatState.stepIndex + 1});
        chatState.stepIndex = 0;
        chatAskCurrent();
        return;
      } else {
        addBot('Subflow no encontrado: ' + subflowName);
        return;
      }
    } else {
      // no subflow matched; fallthrough to options or next
    }
  }

  // If this step has options (within same flow)
  if(step.options){
    // options: object keys are canonical names -> values are arrays [ "1", "label", ... ]
    // check both numbers and words
    let chosenKey = null;
    for(const optKey in step.options){
      const vals = step.options[optKey].map(v=>(''+v).toLowerCase());
      if(vals.some(v=> input.includes(v))){ chosenKey = optKey; break; }
    }
    if(chosenKey){
      // store the canonical option as value of key variable (if key exists)
      if(step.key) chatState.vars[step.key] = chosenKey;
      // advance to next step in same flow
      chatState.stepIndex++;
      // If next step exists and is final message, bot will show it
      chatAskCurrent();
      return;
    } else {
      addBot('No entendÃ­ la opciÃ³n. Responde con alguna de: ' + Object.values(step.options).flat().slice(0,6).join(', '));
      return;
    }
  }

  // If none of the above, just advance to next step in same flow
  chatState.stepIndex++;
  chatAskCurrent();
}

/* Replace variables in a string with current vars */
function replaceVars(text){
  if(!text) return '';
  return text.replace(/{{\s*([^}]+)\s*}}/g, (_,k)=> chatState.vars[k] || '');
}

/* Wrap addBot to auto-replace variables for message displayed immediately after advancing */
(function wrapAsk(){
  const oldAddBot = addBot;
  window.addBot = function(txt){
    // If txt contains placeholders, replace with current vars
    const final = replaceVars(txt);
    oldAddBot(final);
  };
})();

/* initialize chat view */
chatReset();

/* Utility: escape html in small node preview */
function escapeHtml(s){
  if(!s) return '';
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

/* ------------------ Init render ------------------ */
renderCanvas();

/* Update JSON view live every 1s and on interactions */
setInterval(refreshJSONView,1000);
</script>
</body>
</html>
